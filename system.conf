{"slots":{"0":{"name":"emitter","type":{"events":[],"methods":[]}},"1":{"name":"receiver","type":{"events":[],"methods":[]}},"2":{"name":"trackDB","type":{"events":[],"methods":[]}},"3":{"name":"raceDB","type":{"events":[],"methods":[]}},"4":{"name":"recordDB","type":{"events":[],"methods":[]}},"5":{"name":"screen","type":{"events":[],"methods":[]}},"6":{"name":"screen","type":{"events":[],"methods":[]}},"7":{"name":"screen1","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"if channel == \"fdu-centralsplit\" then\n    mess = string.gsub(message, \"|\", '\\\\\"')\n    local part = json.decode(mess)\n    if part == nil then\n        system.print(\"Invalid message: \" .. mess)\n        return false\n    end\n    table.insert(messageParts, {index = part[\"i\"], content = part[\"content\"]})\n    if part[\"i\"] == part[\"len\"] then\n        local fullMessage = getCompleteMessage()\n\n        if part[\"action\"] == \"save-track\" then\n            createTrack(fullMessage)\n        end\n    end\nend\n\nif channel == raceID .. \"-register\" then\n    registerRacer(message)\nend\n\nif channel == raceID .. \"-finish\" then\n    setTime(message)\nend\n\nif channel == \"fdu-addtrack\" then\n    createTrack(message)\nend\n","filter":{"args":[{"variable":"*"},{"variable":"*"}],"signature":"receive(channel,message)","slotKey":"1"},"key":"0"},{"code":"-- Screen receiver system and stats display\n-- Official races require a race adjudicator that mans this board\n\n-- Params\n\n-- Race ID (Sets the active race ID used to receive and store stats, auto in future\nraceID = raceDB.getStringValue(\"activeRaceID\")\ntrackKey = raceDB.getStringValue(\"activeTrackID\")\nactiveTrack = nil\ntrackName = \"\" -- Set from the databank when looking up track key\nmessageParts = {}\nmessageQueue = {}\nconsumerStarted = false\n\n-- Do not adjust version\nversion = \"1.0\"\n\n-- Text controller\nfunction handleTextCommandInput(text)\n    system.print(\"Command: \" .. text)\n    -- Help\n    if text == \"help\" then\n        -- Outputs all commands with a description\n        system.print(\"-==:: DU Racing Command Help ::==-\")\n        system.print('\"list racers\" - lists out all registered racers for this race')\n        system.print('\"disqualify racer RacerName\" - disqualifies RacerName from this race')\n        system.print('\"start race {ALT+1}\" - starts the race and broadcasts start signal to racers')\n        system.print('\"end race {ALT+2}\" - closes all further time submissions to this race')\n        system.print('\"set track track-name\" - sets the active track name')\n        system.print('\"set key your-race-key\" - sets the active race key for the system')\n        system.print('\"list races\" - lists all stored race keys')\n        system.print('\"list tracks\" - lists all stored track keys')\n        return true\n    end\n\n    -- Start Race\n    if text == \"start race\" then\n        return startRace()\n    end\n\n    -- End Race\n    if text == \"end race\" then\n        return endRace()\n    end\n\n    -- List racers\n    if text == \"list racers\" then\n        local race = getRace(raceID)\n        if race == nil then\n            system.print(\"ERROR: No race found with this ID\")\n            return false\n        end\n        local racers = \"\"\n        for key, value in pairs(race[\"racers\"]) do\n            racers = racers .. race[\"racers\"][key][\"name\"] .. \", \"\n        end\n        return system.print(\"Registered racers: \" .. racers)\n    end\n\n    -- Disqualify racer\n    if text:find(\"disqualify racer \") then\n        local dqf = string.gsub(text, \"disqualify racer \", \"\")\n        local race = getRace(raceID)\n        if race == nil then\n            system.print(\"ERROR: No race found with this ID\")\n            return false\n        end\n        local racers = \"\"\n        for key, value in pairs(race[\"racers\"]) do\n            if race[\"racers\"][key][\"name\"] == dqf then\n                race[\"racers\"][key][\"time\"] = \"DQF\"\n                raceDB.setStringValue(raceID, json.encode(race))\n                return system.print(dqf .. \" has been disqualified\")\n            end\n        end\n        return system.print(dqf .. \" was not found\")\n    end\n\n    -- Set race id\n    if text:find(\"set key \") then\n        raceID = string.gsub(text, \"set key \", \"\")\n        raceDB.setStringValue(\"activeRaceID\", raceID)\n        buildRaceStatScreen()\n        return createRace(raceID)\n    end\n\n    -- List all saved race keys\n    if text == \"list races\" then\n        local keys = json.decode(raceDB.getKeys())\n        local out = \"\"\n        for key, value in pairs(keys) do\n            if value ~= \"activeRaceID\" and value ~= \"activeTrackKey\" then\n                out = value .. \", \" .. out\n            end\n        end\n        return system.print(out)\n    end\n\n    -- export race\n    if text:find(\"export race \") then\n        local exportKey = string.gsub(text, \"export race \", \"\")\n        local raceExport = raceDB.getStringValue(exportKey)\n        screen.setHTML(raceExport)\n        return system.print(\"The race has been exported to the screen HTML content\")\n    end\n\n    -- Set track\n    if text:find(\"set track \") then\n        trackKey = string.gsub(text, \"set track \", \"\")\n        if trackDB.hasKey(trackKey) == 1 then\n            raceDB.setStringValue(\"activeTrackID\", trackKey)\n            system.print(\"Track key has been set\")\n            buildRaceStatScreen()\n            return createRace(raceID)\n        end\n        return system.print(\"Track key not found: \" .. trackKey)\n    end\n\n    -- list saved tracks\n    if text == \"list tracks\" then\n        local keys = json.decode(trackDB.getKeys())\n        local out = \"\"\n        for key, value in pairs(keys) do\n            if value ~= \"activeRaceID\" and value ~= \"activeTrackKey\" then\n                out = value .. \", \" .. out\n            end\n        end\n        return system.print(out)\n    end\n\n    system.print(\"SYSTEM: I Can't... \" .. text)\nend\n\nfunction consumeQueue()\n    local sortedMessages = getKeysSortedByValue(\n        messageQueue,\n        function(a, b)\n            return tonumber(tonumber(a[\"time\"]) < tonumber(b[\"time\"]))\n        end\n    )\n    for _, key in ipairs(sortedMessages) do\n        emitter.send(messageQueue[key][\"channel\"], messageQueue[key][\"message\"])\n        unqueueMessage(key)\n        break\n    end        \nend\n\nfunction queueMessage(channel, message)\n    if consumerStarted == false then\n        -- Message queue consumer\n        unit.setTimer(\"consumeQueue\", 1)\n    end\n    table.insert(messageQueue, { channel = channel, message = message, time = system.getTime()})\nend\n\nfunction unqueueMessage(key)\n    table.remove(messageQueue, key)\n    local count = 0\n    for _ in pairs(messageQueue) do count = count + 1 end\n    if count == 0 then \n        system.print(\"stopping timer\")\n        unit.stopTimer(\"consumeQueue\")\n        consumerStarted = false\n    end \nend\n\nfunction getCompleteMessage()\n    local sorted =\n        getKeysSortedByValue(\n        messageParts,\n        function(a, b)\n            return tonumber(a[\"index\"]) < tonumber(b[\"index\"])\n        end\n    )\n    message = \"\"\n    for _, key in ipairs(sorted) do\n        message = message .. messageParts[key][\"content\"]\n    end\n    return message\nend\n\nfunction split(str, maxLength)\n    local lines = {}\n    local partLength = math.ceil(str:len() / maxLength)\n    local len = partLength\n    local startNum = 1\n    local endNum = maxLength\n    while partLength > 0 do\n        table.insert(lines, string.sub(str, startNum, endNum))\n        startNum = startNum + maxLength\n        endNum = endNum + maxLength\n        partLength = partLength - 1\n    end\n    return {lines = lines, length = len}\nend\n\nfunction splitBroadcast(action, channel, message)\n    local index = 1\n    local parts = split(message, 350)\n    for _, line in ipairs(parts[\"lines\"]) do\n        local jsonStr = json.encode({i = index, len = parts[\"length\"], action = action, content = line})\n        local send = string.gsub(jsonStr, '\\\\\"', \"|\")\n        send = string.gsub(send, '\"', '\\\\\"')\n        queueMessage(channel, send)\n        index = index + 1\n    end\nend\n\nfunction getKeysSortedByValue(tbl, sortFunction)\n    local keys = {}\n    for key in pairs(tbl) do\n        table.insert(keys, key)\n    end\n\n    table.sort(\n        keys,\n        function(a, b)\n            return sortFunction(tbl[a], tbl[b])\n        end\n    )\n\n    return keys\nend\n\nfunction createTrack(str)\n    local track = json.decode(str)\n    return trackDB.setStringValue(track[\"name\"], str)\nend\n\n-- Race Functions\n\nfunction createRace(raceID)\n    if trackKey == \"\" or trackKey == nil then\n        return system.print(\"ERROR: No track set, use the 'set track' command\")\n    end\n    if raceID == \"\" or raceID == nil then\n        return system.print(\"ERROR: No race key, use the 'set key' command\")\n    end\n    if raceDB.hasKey(raceID) == 0 then\n        local race = {raceID = raceID, trackKey = trackKey, status = \"pending\", racers = {}}\n        raceDB.setStringValue(raceID, json.encode(race))\n        system.print(\"Created new race\")\n    else\n        -- if the race hasnt started, update the track key\n        local race = getRace(raceID)\n        if race[\"status\"] == \"pending\" then\n            race[\"trackKey\"] = trackKey\n            raceDB.setStringValue(raceID, json.encode(race))\n        end\n    end\nend\n\nfunction getRace(raceID)\n    local race = raceDB.getStringValue(raceID)\n    if race ~= nil then\n        race = json.decode(race)\n        return race\n    end\n    return nil\nend\n\n-- Receive Time\nfunction setTime(timesJSON)\n    -- Receives the time from the ship and stores in the db for this race\n    -- Emits a confirmation message that the message was received, this stops the ship sending it\n    local data = json.decode(timesJSON)\n\n    -- get the race from the db from the raceID passed\n    local race = getRace(data[\"raceID\"])\n    if race == nil then\n        return false\n    end\n\n    if race[\"status\"] == \"ended\" then\n        -- The race has ended\n        return false\n    end\n\n    -- parse and set the times for this user (who should have an index already following registration)\n    for key, value in pairs(race[\"racers\"]) do\n        -- if the current time is not 0 then cheating?\n        if value[\"racer\"] == data[\"racer\"] then\n            -- Set the time here, record laps are stored on diff db\n            --race[\"racers\"][key] = { racer = value[\"racer\"], time = data[\"lapTime\"], name = value[\"name\"] }\n\n            -- Check if this racer is DQF\n            if race[\"racers\"][key][\"time\"] ~= \"DQF\" then\n                race[\"racers\"][key][\"time\"] = data[\"lapTime\"]\n                raceDB.setStringValue(data[\"raceID\"], json.encode(race))\n                checkRankedTime(data[\"lapTime\"], race[\"trackKey\"], data[\"racer\"], data[\"raceID\"])\n            end\n        end\n    end\nend\n\n-- Check ranked time\nfunction checkRankedTime(time, track, racer, raceID)\n    system.print(\"Checking: \" .. time .. \", \" .. track .. \", \" .. racer .. \", \" .. raceID)\n    -- Check top 10 times for this race, if faster then slot in position\n    -- looks like easiest way is to add to array then sort and keep top 10\n    -- Refresh race screen\nend\n\n-- Start race\nfunction startRace()\n    -- Emits a message to prepare, then emits a GO signal 3 seconds later\n    -- Can control traffic lights\n    local race = getRace(raceID)\n    if race == nil then\n        system.print(\"ERROR: No race found with this ID: \" .. raceID)\n        return false\n    end\n    race[\"status\"] = \"started\"\n    -- save the race\n    raceDB.setStringValue(raceID, json.encode(race))\n    -- start the race\n    system.print(\"Race Started!\")\n    emitter.send(raceID, \"start\")\nend\n\n-- End race\nfunction endRace()\n    -- Marks the race as complete, no more times will be accepted and the race is archived\n    local race = getRace(raceID)\n    if race == nil then\n        system.print(\"ERROR: No race found with this ID\")\n        return false\n    end\n    race[\"status\"] = \"ended\"\n    -- save the rcae\n    raceDB.setStringValue(raceID, json.encode(race))\n    emitter.send(raceID, \"end\")\n    return system.print(\"Race has ended\")\nend\n\n-- Register Racer\nfunction registerRacer(registerJSON)\n    -- Adds the playerId to the active race\n    -- emits the track data\n    local data = json.decode(registerJSON)\n    local race = getRace(data[\"raceID\"])\n    if race == nil then\n        return false\n    end\n\n    if race[\"status\"] == \"ended\" then\n        -- The race has ended\n        return false\n    end\n\n    -- add player if he doesnt exist, use IDs for future name changes\n    local racerExists = false\n    for key, value in ipairs(race[\"racers\"]) do\n        if value[\"racer\"] == data[\"racer\"] then\n            racerExists = true\n        end\n    end\n\n    if racerExists == false then\n        local racer = data[\"racer\"]\n        table.insert(race[\"racers\"], {racer = racer, time = 0, name = system.getPlayerName(data[\"racer\"])})\n        raceDB.setStringValue(data[\"raceID\"], json.encode(race))\n        system.print(\"New racer registered\")\n        -- update screen\n        buildRaceStatScreen()\n    else\n        system.print(\"Racer already registered\")\n    end\n\n    -- Emit the track data here, it allows a reset of the board to refetch the data on vehicle\n    local trackJSON = json.encode(activeTrack)\n    splitBroadcast(\"register-save-track\", data[\"racer\"] .. \"-splitmsg\", trackJSON)\nend\n\n-- Race Stats Screen\n\n-- Build current race screen\nfunction buildRaceStatScreen()\n    -- Sets the screen up showing the registered racers in a list and their times in order (if set)\n    local race = getRace(raceID)\n    if race == nil then\n        return false\n    end\n    local sortedKeys =\n        getKeysSortedByValue(\n        race[\"racers\"],\n        function(a, b)\n            return tonumber(a[\"time\"]) ~= nil and tonumber(a[\"time\"]) < tonumber(b[\"time\"]) and tonumber(a[\"time\"]) > 0\n        end\n    )\n    local tableItems = \"\"\n    local pos = 1\n\n    for _, key in ipairs(sortedKeys) do\n        tableItems =\n            tableItems ..\n            \"<tr><td>\" ..\n                pos ..\n                    \"</td><td>\" ..\n                        race[\"racers\"][key][\"name\"] .. \"</td><td>\" .. race[\"racers\"][key][\"time\"] .. \"</td></tr>\"\n        pos = pos + 1\n    end\n\n    screen.setHTML(\n        ' <style> body { background: #000 url(assets.prod.novaquark.com/100694/8f81cc10-5f12-4f17-84db-314fbdb7c186.jpg) center center no-repeat; background-size: cover; color: #a1ecfb !important; } #wrapper { padding: 2vw; width: 100vw; height: 100vh; margin: 0; background-color: rgba(2,17,20,0.65); } #header { height: calc(10vh - 1vw); width: 98vw; } h1 { font-size: 4vw !important; width: 100%; text-align: center; text-shadow: 0 0 4px rgba(161,236,251,0.65); text-transform: uppercase; color: #a1ecfb !important; } #content { height: 85vh; width: 98vw; } table { margin-top: 1vh; width: 100%; } table th { display: none; padding: 1vh 3vh; font-size: 4vw; text-align: center; background-color: rgb(227, 68, 57); } table th:first-child { border-top-left-radius: 20px; } table td { font-size: 1.5vw; padding: 3vh; text-align: center; color: #a1ecfb !important; display: inline-block; } table tbody tr { margin: 1vh 0; display: block; background-color: rgba(2,17,20,0.65); width: calc(100% - 2vh); border: 1px solid rgb(2, 157, 187); } table tbody tr:first-child { box-shadow: 0 0 8px rgba(161,236,251,0.65); } table tbody tr td:nth-child(1){ width: calc(10% - 6vh); } table tbody tr td:nth-child(2){ width: calc(70% - 6vh); } table tbody tr td:nth-child(3){ width: calc(10% - 6vh); } table tbody tr:first-child td { font-size: 3vw; } table tbody tr:nth-child(2) td { font-size: 2.5vw; } table tbody tr:nth-child(3) td { font-size: 2vw; } #footer { height: calc(5vh - 1vw); width: 98vw; } #footer p { text-align: right; font-size: 1.5vw; margin: 0; padding: 0; position: absolute; right: 2vw; bottom: 2vh; } </style> <div id=\"wrapper\"> <div id=\"header\"><h1>' ..\n            trackName ..\n                '</h1></div> <div id=\"content\"> <table> <thead> <tr> <th>Pos</th> <th>Racer</th> <th>Time</th> </tr> </thead> <tbody> ' ..\n                    tableItems ..\n                        ' </tbody> </table> </div> <div id=\"footer\"> <p>du-racing - version ' ..\n                            version .. \"</p> </div> </div> \"\n    )\nend\n\n-- Build race time stats page\n-- Sets up screen showing the race times for the specified track\n\n-- On start\n--raceDB.clear()\n\nsystem.print(\"-==:: DU Racing System Online ::==-\")\nsystem.print(\"Active Race Key: \" .. raceID)\nsystem.print(\"Active Track Key: \" .. trackKey)\n\nif trackKey ~= nil and trackKey ~= \"\" then\n    local trackJson = trackDB.getStringValue(trackKey)\n    activeTrack = json.decode(trackJson)\n    trackName = activeTrack[\"name\"]\nend\n\nif raceID ~= nil and raceID ~= \"\" then\n    createRace(raceID)\nelse\n    system.print(\"SYSTEM: No race ID set, type 'set key your-key-here' to set one\")\nend\n\nbuildRaceStatScreen()\n\n\n\n","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"1"},{"code":"consumeQueue()","filter":{"args":[{"value":"consumeQueue"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"2"},{"code":"handleTextCommandInput(text)","filter":{"args":[{"variable":"*"}],"signature":"inputText(text)","slotKey":"-2"},"key":"3"}],"methods":[],"events":[]}