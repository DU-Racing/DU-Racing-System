{"slots":{"0":{"name":"emitter","type":{"events":[],"methods":[]}},"1":{"name":"receiver","type":{"events":[],"methods":[]}},"2":{"name":"trackDB","type":{"events":[],"methods":[]}},"3":{"name":"raceDB","type":{"events":[],"methods":[]}},"4":{"name":"recordDB","type":{"events":[],"methods":[]}},"5":{"name":"screen","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"-- Lua 5.1+ base64 v3.0 (c) 2009 by Alex Kloss <alexthkloss@web.de>\n-- licensed under the terms of the LGPL2\n\n\n--\n--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n--WITH LATEST CHANGES THE CHANNEL ISN'T DYNAMIC!  WE MUST PASS THAT INFO VIA JSON OBJ\n--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\n-- character table string\nlocal b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nlocal myDebug=true\n-- encoding\nfunction enc(data)\n    return ((data:gsub('.', function(x) \n        local r,b='',x:byte()\n        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end\n        return r;\n    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)\n        if (#x < 6) then return '' end\n        local c=0\n        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end\n        return b:sub(c+1,c+1)\n    end)..({ '', '==', '=' })[#data%3+1])\nend\n\n-- decoding\nfunction dec(data)\n    data = string.gsub(data, '[^'..b..'=]', '')\n    return (data:gsub('.', function(x)\n        if (x == '=') then return '' end\n        local r,f='',(b:find(x)-1)\n        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end\n        return r;\n    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)\n        if (#x ~= 8) then return '' end\n        local c=0\n        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end\n        return string.char(c)\n    end))\nend\n\nfunction mysplit (inputstr, sep)\n        if sep == nil then\n                sep = '%s'\n        end\n        local t={}\n        for str in string.gmatch(inputstr, '([^'..sep..']+)') do\n                table.insert(t, str)\n        end\n        return t\nend\n\nsplit  = mysplit(message, '\\\\@')\nchannel = split[1]\nmessage = split[2]\n\nif myDebug then system.print('System received: \"'..message..'\" on channel: \"'..channel..'\"') end\n\nif message ~= 'DUR-system-received' then --we don't want to try act on our own confirmation\n  if channel == MSG.lastSendChannel and message == 'DUR-vehicle-received' then\n    debugPrint('System. Unqueue message, it was received.  Remaining in queue: '..tostring(MSG.getQueueCount()))\n    MSG:unqueueMessage()\n    \n  --elseif channel == MSG.lastReceived.channel and message == MSG.lastReceived.msg then\n  --  MSG:confirmReceive(channel)\n\n  elseif channel == \"fdu-centralsplit\" then\n    MSG:confirmReceive(channel)\n\n    local part = json.decode(dec(message))\n    if part == nil then\n      system.print(\"Invalid message: \" .. dec(message))\n      return false\n    end\n    table.insert(messageParts, {index = part[\"i\"], content = part[\"content\"]})\n    if part[\"i\"] == part[\"msgPartsCount\"] then\n      local fullMessage = getCompleteMessage()\n\n      --if part[\"action\"] == \"save-track\" then\n        createTrack(fullMessage)\n      --end\n    end\n\n  elseif channel == raceEventName .. \"-register\" then\n    MSG:confirmReceive(channel)\n    registerRacer(message)\n\n  elseif channel == raceEventName .. \"-finish\" then\n    MSG:confirmReceive(channel)\n    setTime(message)\n\n  elseif channel == \"fdu-addtrack\" then\n    MSG:confirmReceive(channel)\n    createTrack(message)\n  else\n    debugPrint('Channel is: '..channel)\n  end\n\n  MSG.lastReceived = {channel=channel,msg=message}\nend\n\n","filter":{"args":[{"variable":"*"}],"signature":"receive(message)","slotKey":"1"},"key":"0"},{"code":"--DU RACING v1.0 created by rexsilex, NinjaFox and cAIRLs\n\n-- Screen receiver system and stats display\n-- Official races require a race adjudicator that mans this board\n-- Params\n\n-- Race ID (Sets the active race ID used to receive and store stats, auto in future\n\nfunction debugPrint(msg)\n  if(myDebug) then\n    system.print(msg)\n  end\nend\n\nraceEventName = raceDB.getStringValue('activeRaceID') or 'No event set.'\ntrackKey = raceDB.getStringValue('activeTrackID')\nactiveTrack = nil\ntrackName = 'No track set.' -- Set from the databank when looking up track key\nmessageParts = {}\nconsumerStarted = false\nmyDebug = true\nmasterId = unit.getMasterPlayerId()\n\n-- Do not adjust version\nversion = '1.0'\n\n-- character table string\nlocal b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\n-- encoding\nfunction enc(data)\n    return ((data:gsub('.', function(x) \n        local r,b='',x:byte()\n        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end\n        return r;\n    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)\n        if (#x < 6) then return '' end\n        local c=0\n        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end\n        return b:sub(c+1,c+1)\n    end)..({ '', '==', '=' })[#data%3+1])\nend\n\n-- decoding\nfunction dec(data)\n    data = string.gsub(data, '[^'..b..'=]', '')\n    return (data:gsub('.', function(x)\n        if (x == '=') then return '' end\n        local r,f='',(b:find(x)-1)\n        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end\n        return r;\n    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)\n        if (#x ~= 8) then return '' end\n        local c=0\n        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end\n        return string.char(c)\n    end))\nend\n\nfunction customEncode(data)\n  local encodedData = enc(json.encode(data))\n  debugPrint('Base64 Encoded Data: '..tostring(encodedData))\n  return encodedData\nend\n-- Text controller\nfunction handleTextCommandInput(text)\n  local commands = {\n    help = function()\n      -- Outputs all commands with a description\n      system.print(\"-==:: DU Racing Command Help ::==-\")\n      system.print('Use \"setTrack\" and \"setRaceEvent\" to create a event under the \"setRaceEvent\"-Name on the \"setTrack\"-Track. Use \"startRace\" to start after all racers registered.')\n      system.print('\"setTrack(trackName)\" - sets the active track.')\n      system.print('\"setRaceEvent(yourRaceName)\" - creates a race event under the name you make up.')\n      system.print('\"startRace\" or {ALT+1} - initializes the start of race sequence.')\n      system.print('\"endRace\" or {ALT+2} - closes all further time submissions to this race (not the be mistaken as crossing the finish line)')\n      system.print('\"listRacers\" - prints out a list of all registered racers for the set race.')\n      system.print('\"disqRacer(racerName)\" - disqualifies the player with \"racerName\" from the set race.')\n      system.print('\"listTracks\" - prints out a list of all stored tracks.')\n    end,\n    \n    setTrack = function(trackKey)\n      if trackDB.hasKey(trackKey) == 1 then\n        raceDB.setStringValue('activeTrackID', trackKey)\n        local trackJson = trackDB.getStringValue(trackKey)\n        activeTrack = json.decode(trackJson)\n        trackName = activeTrack[\"name\"]\n        createRace(raceEventName)\n        buildRaceStatScreen()\n        system.print('Track has been set.')\n      else\n        errorPrint('Could not set track. No such track name stored: \"'..trackKey..'\".')\n      end\n    end,\n    \n    startRace = function()\n      -- Emits a message to prepare, then emits a GO signal 3 seconds later\n      -- Can control traffic lights\n      local race = getRace(raceEventName)\n      if race == nil then\n        return errorPrint('No race found with this name: \"'..raceEventName..'\".')\n      end\n      race[\"status\"] = 'started'\n      -- save the race\n      raceDB.setStringValue(raceEventName, json.encode(race))\n      -- start the race\n      system.print('Race \"'..raceEventName..'\" started!')\n      MSG:queueMessage(raceEventName,'start')\n    end,\n\n    endRace = function() -- Marks the race as complete, no more times will be accepted and the race is archived.\n      local race = getRace(raceEventName)\n      if race == nil then\n        return errorPrint('No race event created that could end.')\n      end\n      race[\"status\"] = 'ended'\n      raceDB.setStringValue(raceEventName, json.encode(race)) -- save the race data\n      MSG:queueMessage(raceEventName,'end')\n      system.print('Race \"'..raceEventName..'\" has ended. No further time submissions are taken.')\n    end,\n\n    -- List racers\n    listRacers = function()\n      local race = getRace(raceEventName)\n      if race == nil then\n        return errorPrint('Can not list racers. No race event name found with this name: \"'..raceEventName..'\".')\n      end\n      local racers\n      for key, value in pairs(race[\"racers\"]) do\n        racers = racers == nil and race[\"racers\"][key][\"name\"] or racers .. ', ' .. race[\"racers\"][key][\"name\"]\n      end\n      system.print('Registered racers for \"'..raceEventName..'\": ' .. racers)\n    end,\n\n    -- Disqualify racer\n    disqRacer = function(dqf)\n      local race = getRace(raceEventName)\n      if race == nil then\n        return errorPrint('Could not disqualify racer \"'..dqf..'\" as there is no race event found with this name: \"'..raceEventName..'\".')\n      end\n      for key, value in pairs(race[\"racers\"]) do\n        if race[\"racers\"][key][\"name\"] == dqf then\n          race[\"racers\"][key][\"time\"] = \"DQF\"\n          raceDB.setStringValue(raceEventName, json.encode(race))\n          return system.print(dqf .. ' has been disqualified from race \"'..raceEventName..'\".')\n        end\n      end\n      errorPrint('Could not disqualify racer \"'..dqf..'\". No racer with this name in the race event.')\n    end,\n\n    -- Set race id\n    setRaceEvent = function(newRaceEventName)\n      raceEventName = newRaceEventName\n      raceDB.setStringValue('activeRaceID', newRaceEventName)\n      createRace(newRaceEventName)\n      buildRaceStatScreen()\n    end,\n\n    -- List all saved race keys\n    listTracks = function()\n      local keys = json.decode(trackDB.getKeys())\n      local out\n      for key, value in pairs(keys) do\n        if value ~= \"activeRaceID\" and value ~= \"activeTrackID\" then\n          out = out == nil and 'Saved tracks: '..value or out..', '..value\n        end\n      end\n      if out ~= nil then\n        system.print(out)\n      else\n        system.print('No tracks saved.')\n      end\n    end,\n    \n    --NEEDED: list all events\n\n    -- export race, hidden function\n    exportRaceEvent = function(exportKey)\n      local raceExport = raceDB.getStringValue(exportKey)\n      if screen then\n        screen.setHTML(raceExport)\n        system.print('The race has been exported to the screen HTML content.')\n      else\n        errorPrint('Could not export race data as there is no screen connected to a slot named \"screen\".')\n      end\n    end\n  }\n\n  if myDebug then system.print('Entered Command: \"'..text..'\".') end\n\n  local paramStart = string.find(text,'%(')\n  local cmd = paramStart and string.sub(text,1,paramStart-1) or text\n  local paramsString = ''\n  \n  if paramStart then\n    local paramEnd = string.find(text,'%)')\n    paramEnd = paramEnd or #text+1--we assume someone just forgot the closing ) and try to process anyway\n    paramsString = string.sub(text,paramStart+1,paramEnd-1)\n  end\n  if commands[cmd] then\n    commands[cmd](paramsString)\n  else\n    errorPrint('Following command could not be executed: \"'..text..'\".')\n  end\nend\n\nMSG = {\n  queue = {},\n  lastSendChannel = '',\n  lastReceived = {channel='',msg=''},\n  \n  queueMessage = function(self, channel, message)\n    table.insert(MSG.queue, {channel = channel, message = message}) --, time = system.getTime()})\n    if not consumerStarted then\n      MSG:consumeQueue() --we can send the first msg instantly.\n      unit.setTimer('consumeMsgQueue', 1)\n      consumerStarted = true\n    end\n  end,\n  \n  getQueueCount = function()\n    local count = 0\n    for _ in pairs(MSG.queue) do count = count+1 end\n    return count\n  end,\n\n  consumeQueue = function()\n    -- local sortedMessages = getKeysSortedByValue(\n      -- MSG.queue,\n      -- function(a, b)\n        -- return a['time'] < b['time']\n      -- end)\n    -- for _, key in ipairs(sortedMessages) do\n      --emitter.send(MSG.queue[key]['channel'], MSG.queue[key]['message'])\n      emitter.broadcast(MSG.queue[1]['channel']..'@'..MSG.queue[1]['message'])\n      MSG.lastSendChannel = MSG.queue[1]['channel']\n      MSG.unqueueMessage(key)\n    --end    \n  end,\n  \n  -- unqueueMessage = function(key)\n    -- table.remove(MSG.queue, key)\n    -- local count = 0\n    -- for _ in pairs(MSG.queue) do count = count + 1 end\n    -- if count == 0 then \n      -- unit.stopTimer('consumeMsgQueue')\n      -- consumerStarted = false\n    -- end\n  -- end,\n  \n  unqueueMessage = function()\n    local function checkQueueEmpty()\n      if #MSG.queue == 0 then\n        unit.stopTimer('consumeMsgQueue')\n        consumerStarted = false\n        return true\n      else\n        return false\n      end\n    end\n    \n    if checkQueueEmpty() == false then\n      table.remove(MSG.queue, 1)\n      checkQueueEmpty()\n    end\n  end,\n\n\tsend = function(self, channel, data)\n\n    local function split(str, maxLength)\n      local splitParts = {}\n      local strLength = str:len()\n\n      local splitCount = math.ceil(strLength / maxLength)\n      local remainingSplitsCount = splitCount\n      local startPos = 1\n      local endPos = maxLength\n      while remainingSplitsCount > 0 do\n        table.insert(splitParts, string.sub(str, startPos, endPos))\n        startPos = endPos + 1\n        endPos = endPos + maxLength > strLength and strLength or endPos + maxLength\n        remainingSplitsCount = remainingSplitsCount - 1\n      end\n      return splitParts, splitCount\n    end\n\n    local index = 1\n    local dataParts, dataPartsCount = split(data, 250)\n    for lineId, dataContent in ipairs(dataParts) do\n      local sendContent = customEncode({i = index, msgPartsCount = dataPartsCount, content = dataContent})\n      MSG:queueMessage(channel, sendContent)\n      index = index + 1\n    end\n\tend,\n  \n  confirmReceive = function(self,channel)\n    MSG:queueMessage(channel,'DUR-system-received')\n  end\n}\n\n\nfunction getCompleteMessage()\n  -- local sorted =\n    -- getKeysSortedByValue(\n    -- messageParts,\n    -- function(a, b)\n      -- return a['index'] < b['index']\n    -- end\n  -- )\n  local assembeledMessage = ''\n  --for order,key in ipairs(sorted) do\n  for key in ipairs(messageParts) do\n    assembeledMessage = assembeledMessage .. messageParts[key]['content']\n  end\n  return assembeledMessage\nend\n\nfunction getKeysSortedByValue(tbl, sortFunction)\n  local keys = {}\n  for key in pairs(tbl) do\n  table.insert(keys, key)\n  end\n\n  table.sort(\n  keys,\n  function(a, b)\n    return sortFunction(tbl[a], tbl[b])\n  end\n  )\n\n  return keys\nend\n\nfunction formatTime(seconds)\n\n  local function leadingZero(num)\n    num = tonumber(num)\n    return num < 10 and '0' .. num or num\n  end\n\n  local function modulus(a, b)\n  return a - math.floor(a / b) * b\n  end\n\n  local hours = math.floor(seconds / 3600)\n  seconds = modulus(seconds, 3600)\n  local minutes = math.floor(seconds / 60)\n  seconds = modulus(seconds, 60)\n\n  return leadingZero(hours) .. ':' .. leadingZero(minutes) .. ':' .. leadingZero(string.format(\"%.3f\", seconds))\nend\n\nfunction createTrack(str)\n  local track = json.decode(str)\n  trackDB.setStringValue(track[\"name\"], str)\nend\n\n-- Race Functions\n\nfunction createRace(raceID)\n  local err = ''\n  if trackKey == '' or trackKey == nil then\n    err = 'Could not create race: No track set, use the \"setTrack\" command. '\n  end\n  if raceEventName == '' or raceEventName == nil then\n    err = err..'Could not create race: No race event set, use the \"setRaceEvent\" command.'\n  end\n  if err ~= '' then\n    return errorPrint(err)\n  else\n    if raceDB.hasKey(raceID) == 0 then\n      local race = {raceEventName = raceID, trackKey = trackKey, status = \"pending\", racers = {}}\n      raceDB.setStringValue(raceID, json.encode(race))\n      system.print('Created new race: \"'..raceID..'\" on track: \"'..trackKey..'\"')\n    else\n      -- if the race hasnt started, update the track key\n      local race = getRace(raceID)\n      if race[\"status\"] == \"pending\" then\n        race[\"trackKey\"] = trackKey\n        raceDB.setStringValue(raceID, json.encode(race))\n      end\n    end\n  end\nend\n\nfunction getRace(raceID)\n  local race = raceDB.getStringValue(raceID)\n  if race ~= nil then\n    race = json.decode(race)\n    return race\n  end\n  return nil\nend\n\n-- Receive Time\nfunction setTime(timesJSON)\n\n  local data = json.decode(timesJSON)\n  if data == '' then\n    -- The ship is sending invalid data so tell it to stop sending\n    -- TODO: Update this to send an error to the vehicle so it can be checked\n    --queueMessage(data['racer'] .. '-data-received', 'Received data')\n    return false\n  end\n\n  --queueMessage(data['racer'] .. '-data-received', 'Received data')\n\n  local race = getRace(data[\"raceEventName\"])\n  if not race then\n    -- TODO: isn't this kind of an error we need to handle as well? I think in this case a ship assumes it's in a race that does not exist?\n    return false \n  end\n\n  if race[\"status\"] == \"ended\" then\n    --This would occur if a race is manually ended before the last player crosses finish line\n    --This stops data being submitted to races after they are completed\n    errorPrint('Racer \"'..system.getPlayerName(data[\"racer\"])..'\" tried submitting a time after the race already ended. Time has not been added.')\n    return false \n  end\n\n  for key, value in pairs(race[\"racers\"]) do\n    if value[\"racer\"] == data[\"racer\"] then\n      -- The racer exists on the board already if DQF, just no time is assigned to them\n      if race[\"racers\"][key][\"time\"] ~= \"DQF\" then\n        race[\"racers\"][key][\"time\"] = data[\"finalTime\"]\n        raceDB.setStringValue(data[\"raceEventName\"], json.encode(race))\n        --checkRankedTime(data[\"finalTime\"], race[\"trackKey\"], data[\"racer\"], data[\"raceEventName\"])\n      end\n    end\n  end\n  buildRaceStatScreen()\nend\n\n-- Check ranked time\n--function checkRankedTime(time, track, racer, raceID)\n  --system.print(\"Checking: \" .. time .. \", \" .. track .. \", \" .. racer .. \", \" .. raceID)\n  -- Check top 10 times for this race, if faster then slot in position\n  -- looks like easiest way is to add to array then sort and keep top 10\n  -- Refresh race screen\n--end\n\n-- Start race\nfunction startRace()\n  -- Emits a message to prepare, then emits a GO signal 3 seconds later\n  -- Can control traffic lights\n  local race = getRace(raceEventName)\n  if race == nil then\n    system.print(\"ERROR: No race found with this name: \"..raceEventName..'\"')\n    return false\n  end\n  race[\"status\"] = \"started\"\n  -- save the race\n  raceDB.setStringValue(raceEventName, json.encode(race))\n  -- start the race\n  system.print('Race \"'..raceEventName..'\" started.')\n  MSG:queueMessage(raceEventName, 'start')\nend\n\n-- Register Racer\nfunction registerRacer(registerJSON)\n  -- Adds the playerId to the active race\n  -- emits the track data\n  local data = json.decode(dec(registerJSON))\n  local race = getRace(data[\"raceEventName\"])\n  if race == nil then\n    return false\n  end\n\n  if race[\"status\"] == \"ended\" then\n    -- The race has ended\n    return false\n  end\n\n  -- add player if he doesnt exist, use IDs for future name changes\n  local racerExists = false\n  for key, value in ipairs(race[\"racers\"]) do\n    if value[\"racer\"] == data[\"racer\"] then\n      racerExists = true\n    end\n  end\n\n  if racerExists == false then\n    local racer = data[\"racer\"]\n    table.insert(race[\"racers\"], {racer = racer, time = 0, name = system.getPlayerName(data[\"racer\"])})\n    raceDB.setStringValue(data[\"raceEventName\"], json.encode(race))\n    system.print('New racer registered.')\n  else\n    system.print('Racer already registered.')\n  end\n  buildRaceStatScreen()\n\n  -- Emit the track data here, it allows a reset of the board to refetch the data on vehicle\n  local trackJSON = json.encode(activeTrack)\n  \n  debugPrint('Sending track JSON: '..trackJSON)\n  MSG:send(data[\"racer\"] .. \"-splitmsg\", trackJSON) --registers and saves track\nend\n\n-- Race Stats Screen\n\n-- Build current race screen\nfunction buildRaceStatScreen() -- Sets the screen up showing the registered racers in a list and their times in order (if set)\n  local race = getRace(raceEventName)\n  local tableItems = ''\n  if race then\n  --  return errorPrint('Screen info can not be build while there is no active race.')\n  --end\n    local sortedKeys = getKeysSortedByValue(\n    race[\"racers\"],\n    function(a, b)\n      return tonumber(a[\"time\"]) ~= nil and tonumber(a[\"time\"]) > 0 and tonumber(a[\"time\"]) < tonumber(b[\"time\"])\n    end\n    )\n    \n    local pos = 1\n\n    for _, key in ipairs(sortedKeys) do\n      local racerTime\n      if race[\"racers\"][key][\"time\"] > 0 then\n        racerTime = formatTime(race[\"racers\"][key][\"time\"])\n      else\n        racerTime = '---'\n      end\n        tableItems = tableItems ..\n        [[<tr>\n          <td>]]..pos..[[</td>\n          <td>]]..race[\"racers\"][key][\"name\"]..[[</td>\n          <td>]]..racerTime..[[</td>\n        </tr>]]\n        pos = pos + 1\n      --end\n    end\n  end\n  local html = [[\n    <style> \n      body { background: #000 url(assets.prod.novaquark.com/100694/8f81cc10-5f12-4f17-84db-314fbdb7c186.jpg) center center no-repeat; background-size: cover; color: #a1ecfb !important; }\n      #wrapper { padding: 2vw; width: 100vw; height: 100vh; margin: 0; background-color: rgba(2,17,20,0.65); }\n      #header { height: calc(10vh - 1vw); width: 98vw; }\n      h1 { font-size: 3.5vw !important; width: 100%; text-align: center; text-shadow: 0 0 4px rgba(161,236,251,0.65); text-transform: uppercase; color: #a1ecfb !important; }\n      #content { height: 85vh; width: 98vw; }\n      table { margin-top: 1vh; width: 100%; }\n      table th { display: none; padding: 1vh 3vh; font-size: 4vw; text-align: center; background-color: rgb(227, 68, 57); }\n      table th:first-child { border-top-left-radius: 20px; }\n      table td { font-size: 1.5vw; padding: 3vh; color: #a1ecfb !important; display: inline-block; }\n      table tbody tr { margin: 1vh 0; display: block; background-color: rgba(2,17,20,0.65); width: calc(100% - 2vh); border: 1px solid rgb(2, 157, 187); }\n      table tbody tr:first-child { box-shadow: 0 0 8px rgba(161,236,251,0.65); }\n      table tbody tr td:nth-child(1){ width: calc(15% - 3vw); }\n      table tbody tr td:nth-child(2){ width: calc(55% - 3vw); }\n      table tbody tr td:nth-child(3){ width: calc(20% - 4vw); }\n      table tbody tr:first-child td { font-size: 3vw; }\n      table tbody tr:nth-child(2) td { font-size: 2.5vw; }\n      table tbody tr:nth-child(3) td { font-size: 2vw; }\n      #footer { height: calc(5vh - 1vw); width: 98vw; }\n      #footer p { text-align: right; font-size: 1.5vw; margin: 0; padding: 0; position: absolute; right: 2vw; bottom: 2vh; }\n    </style>\n    <div id=\"wrapper\">\n      <div id=\"header\">\n      <h1>]]..raceEventName..' @ '..trackName ..[[</h1>\n      </div>\n      <div id=\"content\">\n      <table>\n        <thead>\n        <tr>\n          <th>Pos</th>\n          <th>Racer</th>\n          <th>Time</th>\n        </tr>\n        </thead>\n        <tbody>]]\n        ..tableItems ..\n        [[</tbody>\n      </table>\n      </div>\n      <div id=\"footer\">\n      <p>du-racing - version]]..version ..[[</p>\n      </div>\n    </div>]]\n\n  if screen then \n    screen.setHTML(html)\n  end\n  if screen1 then\n    screen1.setHTML(html)\n  end\nend\n\nfunction errorPrint(msg)\n  return msg and system.print('ERROR: '..tostring(msg))\nend\n\n-- On start\nfunction onStart() \n  local startError = ''\n  system.print('-==:: DU Racing System Online ::==-')  \n  system.print('Active Race Event Name: ' .. raceEventName)\n  system.print('Active Track: ' .. trackKey)\n  system.print('Type \"help\" to get a list of commands.')\n\n  if trackKey ~= nil and trackKey ~= '' then\n    local trackJson = trackDB.getStringValue(trackKey)\n    debugPrint(trackJson)\n    activeTrack = json.decode(dec(trackJson))\n    debugPrint('Active track data: '..tostring(activeTrack))\n    trackName = activeTrack[\"name\"]\n  else \n    startError = 'No active track has been set, type \"setTrack(Track name here)\" to set a track. '\n  end\n\n  if raceEventName ~= nil and raceEventName ~= '' and raceEventName ~= 'No event set.' then\n    createRace(raceEventName)\n  else\n    startError = startError .. 'No race event name set, type \"setRaceEvent(your Race Name here)\" to create an event.'\n  end\n\n  if startError ~= '' then\n    system.print(startError)\n  end\n\n  -- Update race screen\n  buildRaceStatScreen()\n  unit.setTimer('slowUpdate',0.5)\nend\n\nonStart()\n\n\n\n","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"1"},{"code":"MSG:consumeQueue()","filter":{"args":[{"value":"consumeMsgQueue"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"2"},{"code":"buildRaceStatScreen()","filter":{"args":[{"value":"slowUpdate"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"3"},{"code":"handleTextCommandInput(text)","filter":{"args":[{"variable":"*"}],"signature":"inputText(text)","slotKey":"-2"},"key":"4"}],"methods":[],"events":[]}